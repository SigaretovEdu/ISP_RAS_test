# ИСП РАН тестовое задание

>Необходимо разработать программу на языке C++. Программа принимает на вход таблицу истинности (ТИ) булевой функции для четырёх переменных (структуру данных для ТИ можете определить сами). Программа должна 1) построить карту Карно (КК) по ТИ; 2)  с помощью КК построить сокращённую ДНФ; 3) вывести получившуюся формулу в удобочитаемом виде на экран. Программа должна компилироваться и запускаться под Linux, желательно наличие скриптов сборки (Makefile) и набора тестов.

По умолчанию программа считывает на вход следующие данный (как пример файл тест):
```
varNum
01011001...10101010
```
varNum - количество переменных в логической функции, дальнейшие нули и единицы - значения функции при возрастающих аргументах (для 4-х переменных: 0000, 0001, ...)

Т.к. карта Карно (КК) фактически является тором, то она разворачивается на плоскость, где изначальная карта дублируется 9 раз и уже ищутся возможные склейки:

```
1111
1001
1001
1111
```
Становится
```
111111111111
100110011001
100110011001
111111111111
111111111111
100110011001
100110011001
111111111111
111111111111
100110011001
100110011001
111111111111
```
_На данный момент не придумал решения лучше, чем разварачивать на плоскость, было бы интересно узнать, если оно есть_

Каждая из склеек изначально создаётся максимально большой, а затем, если нужно, разделяется на склейки площадью 2^k

При некоторых случаях склейки дублируются, поэтому я оставляю в наборе склеек только те, которые необходимы, но алгоритм нахождения такого набора склеек кажется не самый оптимальный

После склейки КК, собирается итоговое выражение, которое представляет из себя дерево токенов.
По таблице истинности строится другое выражение, состоящие из всех терм. Затем при всех возможных значениях перменных вычисляются значения полученных выражений и сравниваются.

Функция ```test(varNum)``` тестирует минимизацию на всех возможных таблицах истинности, опциональным параметром ```seed``` можно посмотреть конкретный пример, где ```seed``` является десятичным представлением значений таблицы истинности


## Стандартный вывод

```
truth table:
0000 1
0001 0
0010 1
0011 0
0100 0
0101 1
0110 0
0111 0
1000 0
1001 0
1010 1
1011 1
1100 1
1101 0
1110 0
1111 1

karnaugh map:
	00	01	11	10

00	1	0	0	1
01	0	1	0	0
11	1	0	1	0
10	0	0	1	1

expanded karnaugh map:
1001 1001 1001
0100 0100 0100
1010 1010 1010
0011 0011 0011

1001 1001 1001
0100 0100 0100
1010 1010 1010
0011 0011 0011

1001 1001 1001
0100 0100 0100
1010 1010 1010
0011 0011 0011

cuts from karnaugh map:         // полученные склейки на КК (индексация с нуля)
rec:
	2 0
            2 0
rec:
	1 1
            1 1
rec:
	2 2
            3 2
rec:
	3 2
            3 3
rec:
	0 3
            0 0
// выражение, построенное на основе таблицы истинности
f0 = !X0*!X1*!X2*!X3 + !X0*!X1*X2*!X3 + !X0*X1*!X2*X3 + X0*!X1*X2*!X3 + X0*!X1*X2*X3 + X0*X1*!X2*!X3 + X0*X1*X2*X3
// минимизированная функция
f1 = X0*X1*!X2*!X3 + !X0*X1*!X2*X3 + X0*X2*X3 + X0*!X1*X2 + !X0*!X1*!X3

X0 X1 X2 X3  | F0 F1
0  0  0  0   | 1  1
0  0  0  1   | 0  0
0  0  1  0   | 1  1
0  0  1  1   | 0  0
0  1  0  0   | 0  0
0  1  0  1   | 1  1
0  1  1  0   | 0  0
0  1  1  1   | 0  0
1  0  0  0   | 0  0
1  0  0  1   | 0  0
1  0  1  0   | 1  1
1  0  1  1   | 1  1
1  1  0  0   | 1  1
1  1  0  1   | 0  0
1  1  1  0   | 0  0
1  1  1  1   | 1  1
```

Проверил утечки:
```
$ valgrind --leak-check=full ./ISP_RAS < ../test

HEAP SUMMARY:
     in use at exit: 0 bytes in 0 blocks
   total heap usage: 220 allocs, 220 frees, 86,920 bytes allocated

 All heap blocks were freed -- no leaks are possible
```
